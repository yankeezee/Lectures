> [!NOTE]
> You are given an integer array `nums` and an integer `k`.
> 
> In one operation, you can pick two numbers from the array whose sum equals `k` and remove them from the array.
> 
> Return _the maximum number of operations you can perform on the array_.
> 
> **Example 1:**
> 
> **Input:** nums = [1,2,3,4], k = 5
> **Output:** 2
> **Explanation:** Starting with nums = [1,2,3,4]:
> - Remove numbers 1 and 4, then nums = [2,3]
> - Remove numbers 2 and 3, then nums = []
> There are no more pairs that sum up to 5, hence a total of 2 operations.
> 
> **Example 2:**
> 
> **Input:** nums = [3,1,3,4,3], k = 6
> **Output:** 1
> **Explanation:** Starting with nums = [3,1,3,4,3]:
> - Remove the first two 3's, then nums = [1,4,3]
> There are no more pairs that sum up to 6, hence a total of 1 operation.
> 
> **Constraints:**
> 
> - `1 <= nums.length <= 105`
> - `1 <= nums[i] <= 109`
> - `1 <= k <= 109`
> 
### Идея решения задачи
Задача заключается в том, чтобы найти максимальное количество операций, которые можно выполнить над массивом `nums`, где каждая операция состоит в выборе двух чисел, сумма которых равна `k`, и удалении их из массива.

#### Ключевые наблюдения:

1. **Парность чисел**: Для каждого числа `x` в массиве, искомое парное число должно быть `k - x`. Например, если `k = 5` и `x = 2`, то парное число должно быть `3`.
    
2. **Частота чисел**: Количество операций для пары чисел `(x, k - x)` ограничено минимальной частотой этих чисел в массиве. Например, если `x` встречается 3 раза, а `k - x` встречается 2 раза, то максимальное количество операций для этой пары будет `min(3, 2) = 2`.
    
3. **Уникальные случаи**: Если `x == k - x` (т.е., `x = k / 2`), то количество операций для такой пары будет равно `floor(количество x / 2)`. Например, если `k = 6` и `x = 3`, и `3`встречается 3 раза, то можно составить `1` пару (так как `3 / 2 = 1` с округлением вниз).
    

#### Подход:

1. **Подсчет частот**: Сначала подсчитаем, сколько раз каждое число встречается в массиве, используя хэш-таблицу (например, `Counter` в Python).
    
2. **Перебор уникальных чисел**: Для каждого уникального числа `x` в массиве:
    
    - Если `x == k - x`, то добавляем `floor(количество x / 2)` к общему количеству операций.
        
    - Иначе, если `x < k - x` (чтобы избежать дублирования пар, например, `(1,4)` и `(4,1)`), то добавляем `min(количество x, количество k - x)` к общему количеству операций.
        
3. **Возврат результата**: После перебора всех уникальных чисел возвращаем общее количество операций.
    

#### Пример:

- Для `nums = [1,2,3,4]`, `k = 5`:
    
    - Частоты: `{1:1, 2:1, 3:1, 4:1}`.
        
    - Пары: `(1,4)` и `(2,3)`.
        
    - Операции: `min(1,1) + min(1,1) = 2`.
        
- Для `nums = [3,1,3,4,3]`, `k = 6`:
    
    - Частоты: `{3:3, 1:1, 4:1}`.
        
    - Для `x = 3`: `k - x = 3`, так как `x == k - x`, то добавляем `3 // 2 = 1`.
        
    - Другие пары (например, `(1,5)`) не существуют в массиве.
        
    - Операции: `1`.
        
```python
from collections import Counter

def maxOperations(nums, k):
    freq = Counter(nums)
    operations = 0
    for num in freq:
        if num == k - num:
            operations += freq[num] // 2
        elif num < k - num and (k - num) in freq:
            operations += min(freq[num], freq[k - num])
    return operations
```
#### Сложность:

- Подсчет частот: `O(N)`, где `N` — длина массива.
    
- Перебор уникальных чисел: в худшем случае `O(N)`, если все числа уникальны.
    
- Общая сложность: `O(N)`.