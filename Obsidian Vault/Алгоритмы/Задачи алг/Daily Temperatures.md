> [!NOTE]
> Given an array of integers `temperatures` represents the daily temperatures, return _an array_ `answer`_such that_ `answer[i]` _is the number of days you have to wait after the_ `ith` _day to get a warmer temperature_. If there is no future day for which this is possible, keep `answer[i] == 0` instead.
> 
> **Example 1:**
> 
> **Input:** temperatures = [73,74,75,71,69,72,76,73]
> **Output:** [1,1,4,2,1,1,0,0]
> 
> **Example 2:**
> 
> **Input:** temperatures = [30,40,50,60]
> **Output:** [1,1,1,0]
> 
> **Example 3:**
> 
> **Input:** temperatures = [30,60,90]
> **Output:** [1,1,0]
> 
> **Constraints:**
> 
> - `1 <= temperatures.length <= 105`
> - `30 <= temperatures[i] <= 100`
### Идея решения задачи "Daily Temperatures"

**Задача:**  
Для каждого дня `i` в массиве температур `temperatures` нужно найти количество дней, которое нужно подождать до наступления более теплого дня. Если такого дня нет, то результат для `i` должен быть 0.

**Пример:**  
Для `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]` ответ:  
`[1, 1, 4, 2, 1, 1, 0, 0]`.

### Ключевая идея:

Использование **стека (monotonic stack)** для эффективного отслеживания дней, для которых мы еще не нашли более теплый день. Стек будет хранить индексы дней в порядке убывания температур.

### Алгоритм:

1. Инициализируем стек и массив ответов `answer` нулями.
    
2. Проходим по массиву температур:
    
    - Пока стек не пуст и текущая температура больше температуры дня на вершине стека:
        
        - Извлекаем индекс из стека.
            
        - Записываем в `answer[извлеченный_индекс]` разницу между текущим индексом и извлеченным.
            
    - Добавляем текущий индекс в стек.
        
3. Возвращаем `answer`.
    

### Почему это работает:

- Стек поддерживается в порядке убывания температур (индексы дней с неубывающими температурами).
    
- Когда встречается более теплый день, мы можем обновить ответ для всех предыдущих дней, которые ждали более теплой температуры.
    

### Сложность:

- Время: **O(n)**, так как каждый индекс добавляется и извлекается из стека ровно один раз.
    
- Память: **O(n)** для стека в худшем случае (если массив убывающий).
    

### Пример работы:

Для `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`:

- Стек и `answer` меняются следующим образом:
    
    - i=0: стек = [0], answer = [0, 0, 0, 0, 0, 0, 0, 0]
        
    - i=1: 74 > 73 → извлекаем 0, answer[0] = 1; стек = [1]
        
    - i=2: 75 > 74 → извлекаем 1, answer[1] = 1; стек = [2]
        
    - i=3: 71 < 75 → стек = [2, 3]
        
    - i=4: 69 < 71 → стек = [2, 3, 4]
        
    - i=5: 72 > 69 → извлекаем 4, answer[4] = 1; стек = [2, 3]  
        72 > 71 → извлекаем 3, answer[3] = 2; стек = [2]  
        72 < 75 → стек = [2, 5]
        
    - i=6: 76 > 72 → извлекаем 5, answer[5] = 1; стек = [2]  
        76 > 75 → извлекаем 2, answer[2] = 4; стек = []  
        стек = [6]
        
    - i=7: 73 < 76 → стек = [6, 7]
        
- Итоговый `answer`: [1, 1, 4, 2, 1, 1, 0, 0].
    

### Код :

```python
def dailyTemperatures(temperatures):
    answer = [0] * len(temperatures)
    stack = []
    for i, temp in enumerate(temperatures):
        while stack and temp > temperatures[stack[-1]]:
            prev_index = stack.pop()
            answer[prev_index] = i - prev_index
        stack.append(i)
    return answer
```

**Сложность алгоритма:**  
- **Время:** **O(n)** — каждый элемент обрабатывается один раз.  
- **Память:** **O(n)** — в худшем случае стек может хранить все элементы.  

Используется монотонный стек для эффективного поиска ближайшего более теплого дня.