> [!NOTE]
> Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.
> 
> You must implement a solution with a linear runtime complexity and use only constant extra space.
> 
> **Example 1:**
> 
> **Input:** nums = [2,2,1]
> 
> **Output:** 1
> 
> **Example 2:**
> 
> **Input:** nums = [4,1,2,1,2]
> 
> **Output:** 4
> 
> **Example 3:**
> 
> **Input:** nums = [1]
> 
> **Output:** 1

```python
class Solution(object):

	def singleNumber(self, nums):
	
		for num in set(nums):
		
			if nums.count(num)==1:
			
				return num
```
### **Шаги и их сложность:**

1. **`set(nums)`** — создание множества из списка `nums`.
    
    - **Сложность:** `O(n)`, где `n` — длина списка `nums`.
        
    - **Почему?** Нужно пройти по всем элементам списка и добавить их в множество (в среднем `O(1)` на элемент).
        
2. **Цикл `for num in set(nums)`**
    
    - Итерируется по **уникальным элементам** списка.
        
    - В худшем случае (все элементы уникальны) — `O(n)` итераций.
        
    - В среднем (если дубликатов много) — `O(m)`, где `m` — количество уникальных элементов (`m ≤ n`).
        
3. **`nums.count(num)`**
    
    - Проходит по **всему списку `nums`** и подсчитывает, сколько раз встречается `num`.
        
    - **Сложность:** `O(n)` для каждого вызова.
        

---

### **Итоговая сложность:**

- **В худшем случае** (все элементы уникальны):
    
    - `set(nums)` — `O(n)`.
        
    - Цикл выполнится `n` раз, на каждой итерации `nums.count(num)` — `O(n)`.
        
    - **Общая сложность:** `O(n) + O(n * n) = O(n²)`.
        
- **В лучшем случае** (искомый элемент встречается первым в `set(nums)`):
    
    - `set(nums)` — `O(n)`.
        
    - Первая же итерация находит ответ, `nums.count` вызывается 1 раз.
        
    - **Общая сложность:** `O(n) + O(n) = O(n)`.
        
- **В среднем** (если дубликатов много, `m ≈ n/2`):
    
    - `set(nums)` — `O(n)`.
        
    - Цикл выполнится `m` раз, каждый `nums.count` — `O(n)`.
        
    - **Общая сложность:** `O(n) + O(m * n) ≈ O(n²)`.


```python
def singleNumber(self, nums):
    res = 0
    for num in nums:
        res ^= num  # XOR
    return res
```
- **Сложность:** `O(n)` (один проход по списку).
### **Как работает XOR (исключающее ИЛИ) в задаче `singleNumber`?**

XOR (`^`) — это битовая операция, которая работает по принципу:  
**"Если два бита разные, результат `1`, если одинаковые — `0`."**

#### **Свойства XOR:**

1. **Коммутативность:** `a ^ b = b ^ a` (порядок не важен).
    
2. **Ассоциативность:** `(a ^ b) ^ c = a ^ (b ^ c)` (группировка не важна).
    
3. **Свойство нуля:** `a ^ 0 = a` (XOR с нулем не меняет число).
    
4. **Самообратимость:** `a ^ a = 0` (XOR числа с самим собой даёт `0`).
    

---

### **Применение в задаче:**

В массиве все числа, кроме одного, встречаются **дважды**.

- Если выполнить XOR всех чисел, то дубликаты **взаимоуничтожатся** (по свойству `a ^ a = 0`).
    
- Останется только искомое число (по свойству `a ^ 0 = a`).
    

#### **Пример:**

Пусть `nums = [4, 1, 2, 1, 2]`.  
Вычисляем XOR последовательно:

0 ^ 4 = 4  
4 ^ 1 = 5  
5 ^ 2 = 7  
7 ^ 1 = 6  
6 ^ 2 = 4  → ответ `4`.

**Почему так получилось?**

- `1 ^ 1 = 0` и `2 ^ 2 = 0` (дубликаты исчезли).
    
- `0 ^ 4 = 4` (единственное оставшееся число).