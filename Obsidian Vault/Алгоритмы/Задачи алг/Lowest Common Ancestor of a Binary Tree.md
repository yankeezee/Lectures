> [!NOTE]
> Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
> 
> According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”
> 
> **Example 1:**
> 
> ![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
> 
> **Input:** root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
> **Output:** 3
> **Explanation:** The LCA of nodes 5 and 1 is 3.
> 
> **Example 2:**
> 
> ![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
> 
> **Input:** root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
> **Output:** 5
> **Explanation:** The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
> 
> **Example 3:**
> 
> **Input:** root = [1,2], p = 1, q = 2
> **Output:** 1
### Идея решения задачи о наименьшем общем предке (LCA)

**Определение LCA**: Наименьший общий предок (LCA) двух узлов `p` и `q` в дереве — это самый глубокий узел, который является предком как `p`, так и `q`. При этом узел может быть предком самого себя (например, если `p` является предком `q`, то LCA будет `p`).

#### Ключевые моменты:

1. **Рекурсивный обход дерева**: Для каждого узла проверяем, является ли он одним из искомых узлов (`p` или `q`).
    
2. **Проверка поддеревьев**: Рекурсивно ищем `p` и `q` в левом и правом поддеревьях текущего узла.
    
3. **Определение LCA**:
    
    - Если оба узла найдены в разных поддеревьях (левом и правом), то текущий узел — это LCA.
        
    - Если один из узлов найден в одном из поддеревьев, а другой не найден, то LCA — это найденный узел (так как он уже является предком другого узла).
        
    - Если ни один из узлов не найден в поддеревьях, возвращаем `null`.
        

#### Алгоритм:

1. **Базовый случай**: Если текущий узел `null` или равен `p` или `q`, возвращаем текущий узел.
    
2. **Рекурсивный поиск**:
    
    - Ищем `p` и `q` в левом поддереве.
        
    - Ищем `p` и `q` в правом поддереве.
        
3. **Определение LCA**:
    
    - Если оба поддерева вернули не `null`, значит, текущий узел — это LCA.
        
    - Если только одно поддерево вернуло не `null`, значит, LCA находится в этом поддереве.
        
    - Если оба поддерева вернули `null`, значит, искомые узлы не найдены.
#### Пример 1:

- **Вход**: `root = [3,5,1,6,2,0,8,null,null,7,4]`, `p = 5`, `q = 1`
    
- **Обход**:
    
    - Начинаем с корня `3`.
        
    - Левый поддерево (узел `5`): нашли `p = 5`.
        
    - Правый поддерево (узел `1`): нашли `q = 1`.
        
    - Оба поддерева вернули не `null`, значит, LCA — это корень `3`.
        
- **Вывод**: `3`
    

#### Пример 2:

- **Вход**: `root = [3,5,1,6,2,0,8,null,null,7,4]`, `p = 5`, `q = 4`
    
- **Обход**:
    
    - Начинаем с корня `3`.
        
    - Левый поддерево (узел `5`): нашли `p = 5`.
        
    - Правый поддерево (узел `1`): не нашли `q = 4`.
        
    - В левом поддереве узла `5` ищем `q = 4`:
        
        - Левый поддерево (`6`): не нашли.
            
        - Правый поддерево (`2`): не нашли `4`, но в его правом поддереве (`4`) нашли `q = 4`.
            
        - Так как один из узлов (`p = 5`) уже найден, то LCA — это `5`.
            
- **Вывод**: `5`
    

#### Пример 3:

- **Вход**: `root = [1,2]`, `p = 1`, `q = 2`
    
- **Обход**:
    
    - Начинаем с корня `1`.
        
    - Левый поддерево (`2`): нашли `q = 2`.
        
    - Правый поддерево: `null`.
        
    - Так как один из узлов (`p = 1`) уже найден (корень), то LCA — это `1`.
        
- **Вывод**: `1`


```python
def lowestCommonAncestor(root, p, q):
    if not root or root == p or root == q:
        return root
    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)
    if left and right:
        return root
    return left if left else right
```
#### Сложность:

- **Время**: O(n), где n — количество узлов в дереве (в худшем случае обходим все узлы).
    
- **Память**: O(h), где h — высота дерева (глубина рекурсии).